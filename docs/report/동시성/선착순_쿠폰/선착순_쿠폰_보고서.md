# Redis 기반 선착순 쿠폰 발급 시스템 보고서

## 1. 개요

### 1-1) 목적
기존은 대규모 동시 요청시 응답 지연 문제와 성능 저하가 발생할 수 있습니다. 

그래서 다음과 같이 변경하였습니다.
- Redis 기반 선착순 쿠폰 발급 시스템 구현
- 대용량 트래픽 환경에서 안정적인 쿠폰 발급 보장
- 실시간 재고 관리 및 순서 보장

### 1-2) 기존 코드 대비 변경 목적
- **기존 RDBMS 기반 → Redis 기반 마이그레이션**: 단일 `issueCoupon` 메서드에서 `requestCoupon` + `CouponScheduler` 구조로 분리
- **동기 처리 → 비동기 처리**: 사용자 요청 시 즉시 응답, 실제 DB 저장은 스케줄러가 담당
- **API 분리**: `/request` (Redis 기반 요청) + `/issue` (기존 RDBMS 기반) 엔드포인트 분리
- **성능 최적화**: Redis 메모리 기반 처리로 대용량 트래픽 대응, DB 부하 분산
- **사용자 경험 개선**: 쿠폰 발급 요청 시 즉시 성공/실패 여부 응답

### 1-3) 핵심 특징
- **Redis 자료구조 활용**: Set, Sorted Set, AtomicLong
- **비동기 처리**: 요청 API + 스케줄러 분리
- **선착순 보장**: 시간 기반 순서 관리
- **중복 방지**: 사용자별 발급 이력 관리

## 2. 시스템 설계

### 2-1) 아키텍처
```
사용자 요청 → Redis 처리 → 즉시 응답
                ↓
            스케줄러 (3초)
                ↓
            DB 동기화
```

### 2-2) Redis 키 구조 (실제 구현과 일치)
```java
// Redis 키 상수 (CouponService.java)
private static final String COUPON_STOCK_KEY = "coupon:stock:{policyId}";
private static final String COUPON_ISSUE_KEY = "coupon:issue:{policyId}";
private static final String COUPON_ISSUE_PENDING_KEY = "coupon:issue-pending";
private static final String COUPON_ISSUED_USERS_KEY = "coupon:issued-users:{policyId}";
```

- `coupon:stock:{policyId}`: 재고 수량 (AtomicLong)
- `coupon:issue:{policyId}`: 발급 순서 (Sorted Set)
- `coupon:issued-users:{policyId}`: 발급된 사용자 (Set)
- `coupon:issue-pending`: 처리 대기 목록 (Set)

### 2-3) 데이터 흐름
1. **재고 확인**: Redis AtomicLong으로 실시간 재고 체크
2. **중복 방지**: Set으로 사용자별 발급 이력 확인
3. **순서 보장**: Sorted Set으로 시간 기반 순위 관리
4. **비동기 처리**: 스케줄러가 Redis → DB 동기화

## 3. 핵심 로직

### 3-1) 쿠폰 발급 요청 (CouponService.requestCoupon)
```java
public CouponIssueResult requestCoupon(int userId, int policyId) {
    // 1. 재고 확인 (Redis)
    String stockKey = COUPON_STOCK_KEY.replace("{policyId}", String.valueOf(policyId));
    long availableStock = redissonClient.getAtomicLong(stockKey).get();
    
    if (availableStock <= 0) {
        return CouponIssueResult.SOLD_OUT;
    }
    
    // 2. 중복 발급 방지 (Set)
    String issuedUsersKey = COUPON_ISSUED_USERS_KEY.replace("{policyId}", String.valueOf(policyId));
    RSet<String> issuedUsers = redissonClient.getSet(issuedUsersKey);
    if (!issuedUsers.add(String.valueOf(userId))) {
        return CouponIssueResult.ALREADY_ISSUED;
    }
    
    // 3. 선착순 순서 보장 (Sorted Set)
    String issueKey = COUPON_ISSUE_KEY.replace("{policyId}", String.valueOf(policyId));
    RScoredSortedSet<String> issueSet = redissonClient.getScoredSortedSet(issueKey);
    issueSet.add(System.currentTimeMillis(), String.valueOf(userId));
    
    // 4. 순위 확인 및 재고 할당
    int rank = issueSet.rank(String.valueOf(userId));
    
    if (rank < availableStock) {
        // 발급 성공 - pending 목록에 추가
        RSet<String> pendingSet = redissonClient.getSet(COUPON_ISSUE_PENDING_KEY);
        pendingSet.add(policyId + ":" + userId);
        
        // TTL 설정 (24시간)
        issuedUsers.expire(24, TimeUnit.HOURS);
        issueSet.expire(24, TimeUnit.HOURS);
        
        return CouponIssueResult.SUCCESS;
    } else {
        // 재고 부족 - 발급 요청 제거
        issuedUsers.remove(String.valueOf(userId));
        issueSet.remove(String.valueOf(userId));
        return CouponIssueResult.SOLD_OUT;
    }
}
```

### 3-2) 스케줄러 동기화 (CouponScheduler.syncCouponRequests)
```java
@Scheduled(fixedRate = 3000)
@Transactional
public void syncCouponRequests() {
    try {
        log.info("쿠폰 발급 요청 동기화 시작");
        
        // pending된 쿠폰 정책들 조회
        RSet<String> pendingSet = redissonClient.getSet(COUPON_ISSUE_PENDING_KEY);
        Set<String> pendingRequests = pendingSet.readAll();
        
        for (String requestKey : pendingRequests) {
            String[] parts = requestKey.split(":");
            if (parts.length == 2) {
                int policyId = Integer.parseInt(parts[0]);
                int userId = Integer.parseInt(parts[1]);
                
                processCouponRequest(policyId, userId);
                
                // 처리 완료된 요청 제거
                pendingSet.remove(requestKey);
            }
        }
        
        log.info("쿠폰 발급 요청 동기화 완료");
    } catch (Exception e) {
        log.error("쿠폰 발급 요청 동기화 중 오류 발생", e);
    }
}
```

## 4. 성능 및 안정성

### 4-1) 성능 향상
- **즉시 응답**: Redis 메모리 기반 빠른 처리
- **DB 부하 감소**: 스케줄러 기반 배치 처리
- **동시성 처리**: Redis 원자 연산으로 안전성 보장

### 4-2) 안정성 확보
- **TTL 관리**: 24시간 만료로 메모리 관리
- **에러 처리**: 각 단계별 예외 상황 대응
- **데이터 정합성**: Redis → DB 동기화 보장


**주요 성과:**
- 대용량 트래픽 환경 대응 가능
- 실시간 선착순 보장
- 안정적인 중복 방지
- 효율적인 비동기 처리

**기술적 특징:**
- Redis 자료구조 최적 활용
- 스케줄러 기반 배치 처리
- TTL을 통한 메모리 관리
- 원자 연산으로 동시성 안전성 확보
