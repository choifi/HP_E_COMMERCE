# 서비스 확장에 따른 도메인 분리 및 트랜잭션 처리 한계와 대응 방안 설계 문서

---

## 1. 서론

기존 모놀리식 아키텍처에서는 주문, 재고, 포인트, 결제, 쿠폰 등의 로직을 하나의 애플리케이션과 데이터베이스 내에서 통합적으로 처리하며, 단일 트랜잭션으로 데이터 정합성을 보장할 수 있었습니다.

그러나 서비스 확장과 유연한 유지보수를 위해 도메인별로 애플리케이션 서버와 DB를 분리하는 MSA 전환이 필요해졌으며, 이에 따라 분산 트랜잭션 처리의 한계와 대응 방안에 대한 전략적 설계가 필요합니다.

---

## 2. 배포 단위 도메인 분리 적절성 평가

### 2.1 도메인 설계 및 서비스 분리 기준

| 도메인     | 역할 및 책임                          | 독립 배포 단위 | 독립 데이터 저장소 |
|------------|---------------------------------------|----------------|--------------------|
| **Order**      | 주문 생성, 조회, 상태 관리             | ✅             | ✅ (Order DB)      |
| **Product**    | 상품 정보, 재고 관리, 랭킹             | ✅             | ✅ (Product DB)    |
| **Point**      | 포인트 차감 및 적립                    | ✅             | ✅ (Point DB)      |
| **Payment**    | 결제 처리, 결제 취소, 할인 계산        | ✅             | ✅ (Payment DB)    |
| **Coupon**     | 쿠폰 사용, 만료 관리                   | ✅             | ✅ (Coupon DB)     |

#### 🔍 **분리 기준 분석**
- 모든 도메인은 **Single Responsibility Principle(SRP)**에 따라 분리되어 있으며, 각 도메인은 독립적인 기능을 수행하고 있어 **개별 배포 및 확장**이 가능합니다.
- **Database-per-Service** 전략을 통해 각 서비스는 자체 데이터 저장소를 사용하며, 이는 데이터 종속성과 결합도를 줄이는 데 기여합니다.

### 2.2 도메인 간 연관도 및 의존성

#### 📊 **비즈니스 흐름**
도메인 간 비즈니스 흐름은 다음과 같은 순서를 따릅니다:

```
Product → Order → Point → Payment → Coupon
```

#### 🔗 **구현 방식**
- 구현 상에서는 **REST API** 또는 **이벤트 기반 통신(Kafka 등)**으로 서비스 간 결합도를 최소화
- 의존성은 **비동기적 흐름**으로 관리

---

## 3. 트랜잭션 분리에 따른 문제 인식 및 설명

### 3.1 모놀리식과 MSA의 트랜잭션 처리 비교

| 항목             | 모놀리식 구조                                        | MSA 구조                                                   |
|------------------|------------------------------------------------------|-------------------------------------------------------------|
| **트랜잭션 처리**     | `@Transactional`로 하나의 트랜잭션에서 처리           | 각 서비스는 개별 트랜잭션 수행                             |
| **데이터 정합성**     | ACID 보장, 전체 실패 시 롤백                        | 일부 서비스 실패 시 정합성 붕괴 위험                      |
| **장애 전파**        | 내부 예외 처리로 제한됨                             | 네트워크 오류 → 타 서비스 영향 가능성 존재                 |

### 3.2 트랜잭션 분리로 발생 가능한 문제 시나리오

#### ⚠️ **예시 시나리오: 주문 생성 중 일부 서비스 실패**

```
1. Product Service: 재고 차감 성공  ✅
2. Order Service: 주문 생성 성공      ✅
3. Point Service: 포인트 차감 실패    ❌
4. Payment, Coupon: 호출되지 않음    ❌
```
ㅜ
#### 🚨 **발생하는 문제**

| 문제 유형 | 구체적 상황 | 비즈니스 영향 |
|-----------|-------------|---------------|
| **재고 잠금** | 재고는 차감되었지만 주문은 미완료 | 재고 누락, 판매 기회 상실 |
| **유령 주문** | Order는 생성되었지만 결제 미수행 | 회계 불일치, 재무 리스크 |
| **고객 CS** | 쿠폰은 차감되었으나 포인트 실패 | 고객 불만족, CS 비용 증가 |

> 💡 **핵심 위험 요소**: 이러한 부분 실패는 **데이터 정합성 훼손**, **비즈니스 로직 오류**, **운영 장애**로 이어질 수 있습니다.

### 3.3 일관성 보장의 어려움

#### 🔒 **MSA 환경의 제약사항**
- **글로벌 트랜잭션 사용 불가**: 2PC는 성능 저하와 시스템 불안정을 초래
- **상태 추적 필요**: 각 단계의 성공 여부를 추적하고, **상태 전이 관리** 및 **보상 트랜잭션 설계**가 필요
- **최종 일관성 모델**: 궁극적으로 **Eventual Consistency (최종 일관성)** 모델을 기반으로 설계되어야 함

---

## 4. 트랜잭션 분리에 따른 대응 전략 설계

MSA 환경에서는 서비스 간 독립성과 확장성을 확보할 수 있지만, 분산 트랜잭션의 부재로 인해 데이터 정합성과 오류 처리의 복잡성이 증가합니다. 이를 해결하기 위한 핵심 전략은 다음과 같습니다.

### 4.1 Saga 패턴

#### 🎭 **기본 개념**
- 각 서비스는 로컬 트랜잭션을 수행하고, 그 결과를 이벤트로 전달하여 다음 서비스로 비즈니스 흐름을 이어감
- 실패 발생 시 이전 서비스에 보상 트랜잭션을 실행하여 상태를 원래대로 되돌림
- **Choreography 방식**은 서비스 간 직접 이벤트를 주고받아 오케스트레이션 없이 처리 가능


### 4.2 보상 트랜잭션 설계

#### 🔧 **설계 원칙**
- 비정상 상태를 정정할 수 있는 보상 로직을 각 서비스에 별도로 구현
- 트랜잭션 실패 발생 시, 이전 단계의 작업을 취소하는 반대 동작을 실행하여 정합성 유지
- 보상 로직은 비동기적이며, 비즈니스적으로 허용 가능한 상태로 복구하는 것이 목표


### 4.3 Outbox 패턴

#### 📮 **패턴 설명**
- 서비스 내 DB 트랜잭션과 메시지 발행을 하나의 원자적 작업으로 처리
- 이벤트를 DB 내 Outbox 테이블에 먼저 저장한 후, 별도 퍼블리셔가 메시지 브로커로 전송


### 4.4 Dead Letter Queue (DLQ)

#### 📬 **DLQ의 역할**
- 처리할 수 없는 이벤트를 별도로 관리하여 재처리 및 모니터링 가능
- 장애 상황에서의 데이터 손실 방지 및 문제 분석 지원

---

## 5. 운영 및 장애 대응 체계

### 5.1 모니터링 및 추적

#### 🔍 **분산 추적 시스템**
- **Sleuth + Zipkin**: 전체 Saga 흐름 추적 가능
- **트랜잭션 ID 기반**: 각 단계별 실행 상태 및 성능 측정

#### 📊 **메트릭 수집**
- **Prometheus + Grafana**: 이벤트 지연/실패 감지
- **커스텀 메트릭**: Saga 성공률, 실행 시간, 실패 패턴 분석

### 5.2 장애 대응 및 복구

#### 🔄 **자동 복구 메커니즘**
- **재시도 자동화**: 일시적 장애에 대한 자동 재시도
- **회로 차단기 패턴**: 장애 전파 방지를 위한 Circuit Breaker 구현

#### 🛠️ **수동 개입 도구**
- **재시도 & 수동 보상 API**: 재시도 자동화 및 수동 보상 처리 도구 운영
- **Admin Dashboard**: 실패 트랜잭션 상태 확인 및 수동 개입 가능

---

## 6. 마치며

### 6.1 MSA 전환의 성과와 가치

MSA로 전환함에 따라 서비스의 **확장성과 유지보수성**이 크게 향상되었습니다. 각 서비스는 독립적으로 개발, 배포, 운영될 수 있어 **비즈니스 요구에 빠르게 대응**할 수 있습니다. 

특히 **Database-per-Service** 전략을 통해 데이터 종속성을 제거하고, **이벤트 기반 통신**으로 서비스 간 결합도를 최소화하여 **유연한 시스템 아키텍처**를 구축할 수 있었습니다.

### 6.2 분산 트랜잭션 관리의 혁신

**SAGA 패턴**을 도입함으로써 분산 트랜잭션 관리의 복잡성을 해결하였습니다. 기존의 글로벌 트랜잭션으로는 해결할 수 없었던 **서비스 간 독립성**과 **장애 격리**를 달성할 수 있었으며, **보상 트랜잭션**을 통한 **데이터 정합성 보장** 메커니즘을 구축하였습니다.

**Outbox 패턴**과 **Dead Letter Queue**를 활용하여 **이벤트 발행의 신뢰성**을 확보하고, **장애 상황에서의 복구 능력**을 크게 향상시켰습니다.





