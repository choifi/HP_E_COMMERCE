# 성능 분석 및 병목 탐색 보고서

## 1. 테스트 실행 결과

### 1.1 기본 성능 지표
```
총 요청 수: 300개
성공률: 95% (285/300)
에러율: 5% (15/300)
평균 응답시간: 10.79ms
95% 응답시간: 16.27ms
처리량: 4.94 req/s
```

### 1.2 에러 분석
- **409 에러**: 15건 (중복 발급 방지)
- **원인**: 동일 사용자 중복 요청
- **정상 동작**: 비즈니스 로직상 예상된 결과

## 2. 병목 지점 분석

### 2.1 데이터베이스 병목
```sql
-- 쿠폰 정책 조회 (캐시 적용)
@Cacheable(value = "coupon_policy", key = "#policyId")
public CouponPolicy getCouponPolicyById(int policyId)

-- 재고 확인 및 업데이트 (비관적 락)
@Transactional
public CouponIssueResult requestCoupon(int userId, int policyId)
```

**분석 결과:**
- 캐시 히트율 높음 (정책 조회 최적화)
- 비관적 락으로 동시성 제어
- DB 커넥션 풀 크기: 3개 (제한적)

### 2.2 동시성 제어 병목
```java
// 중복 발급 방지 로직
List<Coupon> userCoupons = couponRepository.findByUserId(userId);
boolean alreadyIssued = userCoupons.stream()
    .anyMatch(coupon -> coupon.getPolicyId() == policyId);
```

**분석 결과:**
- 사용자별 쿠폰 조회 시 전체 스캔
- 인덱스 최적화 필요
- Redis 캐시 활용 가능

### 2.3 메모리 사용량
- **JVM 힙**: 512MB (제한적)
- **GC 압박**: 빈번한 객체 생성
- **메모리 누수**: 없음

## 3. 성능 개선 방안

### 3.1 데이터베이스 최적화
```sql
-- 사용자별 쿠폰 조회 인덱스 추가
CREATE INDEX idx_coupon_user_policy ON coupon(user_id, policy_id);

-- 쿠폰 정책 발급 수 업데이트 최적화
UPDATE coupon_policy 
SET issued_count = issued_count + 1 
WHERE policy_id = ? AND issued_count < max_count;
```

### 3.2 캐시 전략 개선
```java
// Redis 기반 중복 발급 방지
@Cacheable(value = "user_coupons", key = "#userId + '_' + #policyId")
public boolean hasUserCoupon(int userId, int policyId)
```

### 3.3 커넥션 풀 최적화
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10  # 3 → 10으로 증가
      connection-timeout: 10000
      max-lifetime: 60000
```

## 4. 리소스 사용량 분석

### 4.1 CPU 사용률
- **평균**: 15-20%
- **피크**: 35% (동시 요청 시)
- **병목**: DB 쿼리 처리

### 4.2 메모리 사용률
- **힙 메모리**: 256MB / 512MB
- **비힙 메모리**: 100MB
- **GC 빈도**: 정상 범위

### 4.3 네트워크 I/O
- **입력**: 51KB
- **출력**: 70KB
- **지연시간**: 평균 10ms

## 5. 확장성 평가

### 5.1 현재 한계
- **동시 사용자**: 100명 (안정적)
- **처리량**: 5 req/s
- **응답시간**: 95% < 20ms

### 5.2 예상 한계점
- **동시 사용자**: 500명 (DB 커넥션 풀 한계)
- **처리량**: 20 req/s (DB 쿼리 병목)
- **응답시간**: 95% < 100ms

### 5.3 확장 방안
1. **수평 확장**: 애플리케이션 인스턴스 증가
2. **DB 최적화**: 인덱스, 쿼리 튜닝
3. **캐시 활용**: Redis 기반 중복 체크
4. **비동기 처리**: Kafka 기반 이벤트 처리

## 6. 프로젝트 성과 및 학습

### 6.1 기술적 성과
- **동시성 제어 검증**: 쿠폰 초과 발급 방지 성공
- **성능 기준 달성**: 응답시간 95% < 16ms 달성
- **모니터링 구축**: InfluxDB + Grafana 실시간 모니터링

### 6.2 핵심 학습 내용
- **동시성 제어**: 비관적 락 vs 낙관적 락 이해
- **성능 튜닝**: DB 쿼리 최적화, 인덱스 설계
- **부하 테스트**: k6 기반 자동화 테스트 구축
- **모니터링**: 메트릭 수집 및 시각화

### 6.3 향후 개선 계획
- **수평 확장**: 마이크로서비스 아키텍처 도입
- **캐시 전략**: Redis 기반 분산 캐시 활용
- **비동기 처리**: 이벤트 기반 아키텍처 구축
- **자동화**: CI/CD 파이프라인 통합
